<!doctype html>
<html lang="it">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Pascoli – Corridoio</title>
<style>
  body{margin:0;overflow:hidden;background:#0b1020;}
  canvas{display:block;}
  #info{
    position:fixed;top:10px;left:10px;
    color:white;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
    background:rgba(0,0,0,0.45);
    padding:8px 12px;border-radius:10px;
    border:1px solid rgba(255,255,255,0.15);
  }
</style>
</head>
<body>
<div id="info">Click nel canvas → attiva mouse (pointer lock). WASD muovi. <b>Click</b> sui quadri (mirino al centro) → cambia colore.</div>

<script type="module">
import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';

const scene=new THREE.Scene();
scene.background=new THREE.Color(0x0b1020);
scene.fog=new THREE.Fog(0x0b1020,10,80);

const camera=new THREE.PerspectiveCamera(60,window.innerWidth/window.innerHeight,0.1,200);
camera.position.set(0,1.6,5);

const renderer=new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth,window.innerHeight);
renderer.outputColorSpace=THREE.SRGBColorSpace;
document.body.appendChild(renderer.domElement);

// Lights
scene.add(new THREE.HemisphereLight(0x7ab8ff,0x0b1020,0.42));
const dirLight=new THREE.DirectionalLight(0xffffff,0.85);
dirLight.position.set(5,10,5);
scene.add(dirLight);

// Corridor
const floor=new THREE.Mesh(
  new THREE.PlaneGeometry(6,60),
  new THREE.MeshStandardMaterial({color:0x1b2740,roughness:0.9})
);
floor.rotation.x=-Math.PI/2;
floor.position.z=-30;
scene.add(floor);

const wallMat=new THREE.MeshStandardMaterial({color:0x121a2c,roughness:0.95});
const wallLeft=new THREE.Mesh(new THREE.BoxGeometry(0.2,3,60),wallMat);
wallLeft.position.set(-3,1.5,-30);
scene.add(wallLeft);

const wallRight=new THREE.Mesh(new THREE.BoxGeometry(0.2,3,60),wallMat);
wallRight.position.set(3,1.5,-30);
scene.add(wallRight);

// ==== Fake frames (clickable) ====
const frames = [];
const frameOff = new THREE.MeshStandardMaterial({
  color:0x0e1426,
  roughness:0.92,
  metalness:0.05,
  emissive:0x050814,
  emissiveIntensity:0.35
});
const frameOn  = new THREE.MeshStandardMaterial({
  color:0x1d3b7a,
  roughness:0.75,
  metalness:0.10,
  emissive:0x1c4cff,
  emissiveIntensity:0.55
});
const borderMat = new THREE.MeshStandardMaterial({color:0x2a3d66,roughness:0.7,metalness:0.2});

function makeFrame(x, rotY, z){
  const g = new THREE.Group();
  g.position.set(x,1.6,z);
  g.rotation.y = rotY;

  const panel = new THREE.Mesh(new THREE.PlaneGeometry(1.6,1.05), frameOff.clone());
  panel.userData.isFramePanel = true;
  g.add(panel);

  // border
  const border = new THREE.Mesh(new THREE.PlaneGeometry(1.72,1.17), borderMat);
  border.position.z = -0.01;
  g.add(border);

  // inner trim
  const trim = new THREE.Mesh(new THREE.PlaneGeometry(1.64,1.09), borderMat);
  trim.position.z = 0.01;
  trim.material = borderMat.clone();
  trim.material.color.setHex(0x223358);
  g.add(trim);

  // placeholder "canvas" (finto quadro) - una macchia chiara centrale
  const art = new THREE.Mesh(new THREE.PlaneGeometry(1.42,0.85), new THREE.MeshStandardMaterial({
    color:0x2b2f44, roughness:0.9, metalness:0.0, emissive:0x0a0f22, emissiveIntensity:0.45
  }));
  art.position.z = 0.02;
  g.add(art);

  g.userData.toggled = false;
  frames.push(g);
  scene.add(g);
}

const zs=[-8,-16,-24,-32,-40,-48];
for(let i=0;i<zs.length;i++){
  makeFrame(-2.88, Math.PI/2, zs[i]);
  makeFrame( 2.88,-Math.PI/2, zs[i]);
}

// Video setup
const video=document.createElement('video');
video.src="pascoli-bassaQ.mp4";
video.loop=true;
video.muted=true;
video.playsInline=true;
// don't autoplay until user gesture
const videoTexture=new THREE.VideoTexture(video);
videoTexture.colorSpace=THREE.SRGBColorSpace;

const videoMat=new THREE.MeshBasicMaterial({
  map:videoTexture,
  transparent:true,
  opacity:1
});
const videoPlane=new THREE.Mesh(new THREE.PlaneGeometry(1.6,2.2),videoMat);
scene.add(videoPlane);

// Controls
const keys={};
window.addEventListener("keydown",e=>keys[e.code]=true);
window.addEventListener("keyup",e=>keys[e.code]=false);

let yaw=0,pitch=0;

// Pointer lock + start video on first click
renderer.domElement.addEventListener("click",()=>{
  renderer.domElement.requestPointerLock();
  video.play().catch(()=>{});
});

document.addEventListener("mousemove",e=>{
  if(document.pointerLockElement===renderer.domElement){
    yaw-=e.movementX*0.002;
    pitch-=e.movementY*0.002;
    pitch=Math.max(-1.2,Math.min(1.2,pitch));
  }
});

// Raycast click on frames (uses center reticle when locked)
const raycaster = new THREE.Raycaster();
const ndc = new THREE.Vector2(0,0);

function toggleFrame(hitObj){
  // climb to group
  let g = hitObj;
  while(g && !(g instanceof THREE.Group)) g = g.parent;
  if(!g) return;
  // the panel is first child
  const panel = g.children.find(c=>c.userData?.isFramePanel);
  if(!panel) return;

  g.userData.toggled = !g.userData.toggled;
  panel.material = (g.userData.toggled ? frameOn.clone() : frameOff.clone());
}

window.addEventListener("mousedown",(e)=>{
  if(e.button!==0) return;
  // Only handle frame toggle when pointer locked; otherwise user is probably trying to lock
  if(document.pointerLockElement!==renderer.domElement) return;
  raycaster.setFromCamera(ndc, camera);
  const hits = raycaster.intersectObjects(frames, true);
  if(hits.length){
    toggleFrame(hits[0].object);
  }
});

// Animation loop
function animate(){
  requestAnimationFrame(animate);

  camera.rotation.y=yaw;
  camera.rotation.x=pitch;

  if(keys["KeyW"])camera.position.z-=0.1;
  if(keys["KeyS"])camera.position.z+=0.1;
  if(keys["KeyA"])camera.position.x-=0.1;
  if(keys["KeyD"])camera.position.x+=0.1;

  // clamp within corridor
  camera.position.x = Math.max(-2.2, Math.min(2.2, camera.position.x));
  camera.position.z = Math.max(-58, Math.min(3, camera.position.z));

  // Video always in front on corridor center line
  videoPlane.position.set(0,1.6,camera.position.z-2.3);
  videoPlane.lookAt(camera.position);

  renderer.render(scene,camera);
}
animate();

window.addEventListener("resize",()=>{
  camera.aspect=window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth,window.innerHeight);
});
</script>
</body>
</html>
