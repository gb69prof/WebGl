<!doctype html>
<html lang="it">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no">
<title>Museo 3D – iPad</title>
<style>
html,body{margin:0;height:100%;overflow:hidden;background:#000}
canvas{width:100%;height:100%;display:block;touch-action:none}
#overlay{position:fixed;inset:0;background:rgba(0,0,0,.92);display:none;align-items:center;justify-content:center;z-index:10}
#overlay img{max-width:100%;max-height:100%;border-radius:12px}
#hud{position:fixed;left:0;right:0;bottom:10px;text-align:center;color:#ddd;
font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;font-size:13px;z-index:5;
text-shadow:0 1px 2px rgba(0,0,0,.7);}
.badge{display:inline-block;padding:6px 10px;border-radius:999px;background:rgba(0,0,0,.35);backdrop-filter: blur(6px);}
</style>
</head>
<body>
<div id="overlay"><img id="full"></div>
<div id="hud"><span class="badge">1 dito: guarda · 2 dita: cammina · Tap quadro: fullscreen</span></div>

<script type="module">
import * as THREE from "https://unpkg.com/three@0.160.0/build/three.module.js";

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(65, innerWidth/innerHeight, 0.1, 100);
camera.position.set(0, 1.65, 4.5);
camera.rotation.order="YXZ";

const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(innerWidth, innerHeight);
document.body.appendChild(renderer.domElement);

// --- Textures
const loader = new THREE.TextureLoader();
const wallsTex = loader.load("assets/walls.jpg");
wallsTex.colorSpace = THREE.SRGBColorSpace;

// Procedural floor (parquet-ish) and ceiling (simple)
function makeFloorTexture() {
  const c=document.createElement("canvas"); c.width=1024; c.height=1024;
  const g=c.getContext("2d");
  g.fillStyle="#7a5a3a"; g.fillRect(0,0,c.width,c.height);
  // planks
  const plankW=128;
  for(let y=0;y<c.height;y+=64){
    for(let x=0;x<c.width;x+=plankW){
      const v= (Math.random()*20 - 10);
      g.fillStyle=`rgb(${122+v},${90+v},${58+v})`;
      g.fillRect(x,y,plankW,64);
      g.strokeStyle="rgba(0,0,0,.12)";
      g.strokeRect(x,y,plankW,64);
    }
  }
  // subtle shine
  const grad=g.createLinearGradient(0,0,0,c.height);
  grad.addColorStop(0,"rgba(255,255,255,.08)");
  grad.addColorStop(1,"rgba(0,0,0,.10)");
  g.fillStyle=grad; g.fillRect(0,0,c.width,c.height);
  const tex=new THREE.CanvasTexture(c);
  tex.colorSpace = THREE.SRGBColorSpace;
  tex.wrapS=tex.wrapT=THREE.RepeatWrapping;
  tex.repeat.set(1.5,1.5);
  return tex;
}

function makeCeilingTexture() {
  const c=document.createElement("canvas"); c.width=1024; c.height=1024;
  const g=c.getContext("2d");
  g.fillStyle="#f2f0ea"; g.fillRect(0,0,c.width,c.height);
  // faint vignette
  const grad=g.createRadialGradient(512,512,50,512,512,700);
  grad.addColorStop(0,"rgba(255,255,255,.0)");
  grad.addColorStop(1,"rgba(0,0,0,.08)");
  g.fillStyle=grad; g.fillRect(0,0,c.width,c.height);
  const tex=new THREE.CanvasTexture(c);
  tex.colorSpace = THREE.SRGBColorSpace;
  return tex;
}

const floorTex = makeFloorTexture();
const ceilTex  = makeCeilingTexture();

// --- Room (6 faces with different materials)
const materials = [
  new THREE.MeshBasicMaterial({ map: wallsTex, side: THREE.BackSide }), // +x
  new THREE.MeshBasicMaterial({ map: wallsTex, side: THREE.BackSide }), // -x
  new THREE.MeshBasicMaterial({ map: ceilTex,  side: THREE.BackSide }), // +y (top)
  new THREE.MeshBasicMaterial({ map: floorTex, side: THREE.BackSide }), // -y (bottom)
  new THREE.MeshBasicMaterial({ map: wallsTex, side: THREE.BackSide }), // +z
  new THREE.MeshBasicMaterial({ map: wallsTex, side: THREE.BackSide }), // -z
];

const room = new THREE.Mesh(new THREE.BoxGeometry(18,6,18), materials);
scene.add(room);

// Light (simple, stable on iPad)
scene.add(new THREE.AmbientLight(0xffffff, 0.85));

// --- Artworks (independent objects attached to walls)
const rayTargets=[];
const placements = [{"file": "Filosofia-base.PNG", "x": -8.7, "z": -6.0, "y": 2.1, "ry": 1.5707963267948966}, {"file": "Leopardi-storico1.png", "x": -8.7, "z": -2.0, "y": 2.1, "ry": 1.5707963267948966}, {"file": "IMG_4016.png", "x": -8.7, "z": 2.0, "y": 2.1, "ry": 1.5707963267948966}, {"file": "IMG_4011.png", "x": -8.7, "z": 6.0, "y": 2.1, "ry": 1.5707963267948966}, {"file": "IMG_4018.png", "x": 8.7, "z": -6.0, "y": 2.1, "ry": -1.5707963267948966}, {"file": "IMG_4019.png", "x": 8.7, "z": -2.0, "y": 2.1, "ry": -1.5707963267948966}, {"file": "IMG_4021.png", "x": 8.7, "z": 2.0, "y": 2.1, "ry": -1.5707963267948966}, {"file": "IMG_4023.png", "x": 8.7, "z": 6.0, "y": 2.1, "ry": -1.5707963267948966}, {"file": "IMG_4027.png", "x": -3.0, "z": -8.7, "y": 2.1, "ry": 0.0}];

function addFrame(p) {
  const t = loader.load("assets/" + p.file);
  t.colorSpace = THREE.SRGBColorSpace;

  const mesh = new THREE.Mesh(
    new THREE.PlaneGeometry(2.6, 1.7),
    new THREE.MeshStandardMaterial({ map: t, roughness: 0.9, metalness: 0.0 })
  );

  mesh.position.set(p.x, p.y, p.z);
  mesh.rotation.y = p.ry;
  // Slight offset from wall to avoid z-fighting
  const eps = 0.02;
  mesh.position.x += Math.cos(p.ry) * eps;
  mesh.position.z += Math.sin(p.ry) * eps;

  mesh.userData = { file: p.file };
  scene.add(mesh);
  rayTargets.push(mesh);

  // Simple "frame" border (thin)
  const border = new THREE.Mesh(
    new THREE.PlaneGeometry(2.72, 1.82),
    new THREE.MeshBasicMaterial({ color: 0x2b2116 })
  );
  border.position.copy(mesh.position);
  border.rotation.copy(mesh.rotation);
  border.position.x += Math.cos(p.ry) * (-0.002);
  border.position.z += Math.sin(p.ry) * (-0.002);
  scene.add(border);
}

placements.forEach(addFrame);

// --- Fullscreen overlay
const overlay=document.getElementById("overlay");
const full=document.getElementById("full");
overlay.onclick=()=>overlay.style.display="none";

const ray=new THREE.Raycaster();
const mouse=new THREE.Vector2();

function pick(clientX, clientY) {
  mouse.x = (clientX / innerWidth) * 2 - 1;
  mouse.y = -(clientY / innerHeight) * 2 + 1;
  ray.setFromCamera(mouse, camera);
  const hit = ray.intersectObjects(rayTargets);
  if (hit.length) {
    full.src = "assets/" + hit[0].object.userData.file;
    overlay.style.display = "flex";
  }
}

// --- Touch controls: 1 finger look, 2 finger move
let yaw=0, pitch=0;
const pointers = new Map(); // id -> {x,y}
let lastMid = null;

function clamp(v,a,b){ return Math.max(a, Math.min(b,v)); }

function updateCameraRotation(dx,dy) {
  yaw  -= dx * 0.003;
  pitch-= dy * 0.003;
  pitch = clamp(pitch, -1.25, 1.25);
  camera.rotation.set(pitch, yaw, 0);
}

function moveCamera(dx, dy) {
  // dy: forward/back, dx: strafe
  const speed = 0.01; // tuned for iPad
  const forward = new THREE.Vector3(0,0,-1).applyEuler(camera.rotation);
  forward.y = 0; forward.normalize();
  const right = new THREE.Vector3(1,0,0).applyEuler(camera.rotation);
  right.y = 0; right.normalize();

  camera.position.addScaledVector(forward, -dy * speed);
  camera.position.addScaledVector(right,    dx * speed);

  // keep inside the room bounds
  camera.position.x = clamp(camera.position.x, -7.5, 7.5);
  camera.position.z = clamp(camera.position.z, -7.5, 7.5);
}

renderer.domElement.addEventListener("pointerdown", (e)=>{
  renderer.domElement.setPointerCapture(e.pointerId);
  pointers.set(e.pointerId, {x:e.clientX, y:e.clientY});
  if (pointers.size===2) {
    const arr=[...pointers.values()];
    lastMid = {x:(arr[0].x+arr[1].x)/2, y:(arr[0].y+arr[1].y)/2};
  }
});

renderer.domElement.addEventListener("pointermove", (e)=>{
  if (!pointers.has(e.pointerId)) return;
  const prev = pointers.get(e.pointerId);
  pointers.set(e.pointerId, {x:e.clientX, y:e.clientY});

  if (pointers.size===1) {
    updateCameraRotation(e.movementX, e.movementY);
  } else if (pointers.size===2) {
    const arr=[...pointers.values()];
    const mid={x:(arr[0].x+arr[1].x)/2, y:(arr[0].y+arr[1].y)/2};
    if (lastMid) {
      const dx = mid.x - lastMid.x;
      const dy = mid.y - lastMid.y;
      moveCamera(dx, dy);
    }
    lastMid = mid;
  }
});

renderer.domElement.addEventListener("pointerup", (e)=>{
  // Tap detection: if it was a quick up with one pointer, try pick
  const wasSingle = pointers.size===1;
  pointers.delete(e.pointerId);
  if (pointers.size<2) lastMid=null;
  if (wasSingle && overlay.style.display!=="flex") {
    pick(e.clientX, e.clientY);
  }
});

renderer.domElement.addEventListener("pointercancel", (e)=>{
  pointers.delete(e.pointerId);
  if (pointers.size<2) lastMid=null;
});

function animate() {
  renderer.render(scene, camera);
  requestAnimationFrame(animate);
}
animate();

onresize=()=>{
  camera.aspect=innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
};
</script>
</body>
</html>
