<!doctype html>
<html lang="it">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>Museo 3D iPad — quadri interattivi</title>
  <style>
    html, body { margin:0; height:100%; overflow:hidden; background:#0b0c10; }
    canvas { display:block; width:100%; height:100%; touch-action:none; }

    #hud{
      position:fixed; left:12px; top:12px; z-index:10;
      font:14px/1.35 system-ui, -apple-system, Segoe UI, Roboto, Arial;
      color:#e6e6e6; background:rgba(0,0,0,.45);
      padding:10px 12px; border-radius:12px; backdrop-filter: blur(8px);
      max-width: 560px; user-select:none;
    }
    #hud b{ color:#ffd66b; }
    #hud .small{ opacity:.9; margin-top:6px; }
    #dot{
      position:fixed; left:50%; top:50%; z-index:9;
      width:8px; height:8px; margin-left:-4px; margin-top:-4px;
      border-radius:999px;
      background:rgba(255,214,107,.9);
      opacity:.45;
      pointer-events:none;
    }

    /* Fullscreen artwork overlay */
    #overlay{
      position:fixed; inset:0; z-index:999;
      background:rgba(0,0,0,.92);
      display:none;
      align-items:center; justify-content:center;
      padding:12px;
      touch-action:none;
    }
    #overlay img{
      max-width:100%;
      max-height:100%;
      object-fit:contain;
      border-radius:14px;
      box-shadow: 0 14px 50px rgba(0,0,0,.55);
    }
    #overlay .hint{
      position:fixed; left:12px; right:12px; bottom:14px;
      text-align:center;
      font:14px/1.25 system-ui, -apple-system, Segoe UI, Roboto, Arial;
      color:rgba(255,255,255,.75);
      user-select:none;
    }
  </style>
</head>
<body>
  <div id="hud">
    <b>Museo 3D (iPad)</b> — quadri interattivi<br/>
    <div class="small">
      1 dito: guardi • 2 dita: ti muovi (su/giù avanti-indietro, dx/sx strafe) • tap su un quadro: schermo intero
    </div>
  </div>

  <div id="dot"></div>

  <div id="overlay">
    <img id="overlayImg" alt="quadro" />
    <div class="hint">Tap per tornare alla stanza</div>
  </div>

<script type="module">
  import * as THREE from "https://unpkg.com/three@0.160.0/build/three.module.js";

  // ====== CONFIG ======
  const ASSETS = [
    { file: "Filosofia-base.PNG",  title: "Filosofia base" },
    { file: "Leopardi-storico1.png", title: "Leopardi (ritratto)" },
    { file: "IMG_4016.png", title: "L'Infinito" },
    { file: "IMG_4011.png", title: "Sensismo e poetica" },
    { file: "IMG_4018.png", title: "Idillio" },
    { file: "IMG_4019.png", title: "Meccanicismo" },
    { file: "IMG_4021.png", title: "Processo alla Natura" },
    { file: "IMG_4023.png", title: "Tre immagini simbolo" },
    { file: "IMG_4027.png", title: "Pessimismo cosmico" },
  ];

  // ====== UI overlay ======
  const overlay = document.getElementById("overlay");
  const overlayImg = document.getElementById("overlayImg");
  function openOverlay(src){
    overlayImg.src = src;
    overlay.style.display = "flex";
  }
  function closeOverlay(){
    overlay.style.display = "none";
    overlayImg.removeAttribute("src");
  }
  overlay.addEventListener("pointerdown", (e) => {
    e.preventDefault();
    closeOverlay();
  }, { passive:false });

  // ====== Scene / Camera / Renderer ======
  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x0b0c10);

  const camera = new THREE.PerspectiveCamera(70, innerWidth/innerHeight, 0.05, 200);
  camera.position.set(0, 1.65, 5.2);
  camera.rotation.order = "YXZ";

  const renderer = new THREE.WebGLRenderer({ antialias:true, alpha:false });
  renderer.setPixelRatio(Math.max(1, devicePixelRatio || 1));
  renderer.setSize(innerWidth, innerHeight);
  renderer.shadowMap.enabled = true;
  document.body.appendChild(renderer.domElement);

  // ====== Lights ======
  scene.add(new THREE.AmbientLight(0xffffff, 0.28));

  const spot1 = new THREE.SpotLight(0xfff3d6, 1.3, 28, Math.PI/6, 0.35, 1);
  spot1.position.set(-2.8, 4.6, 1.0);
  spot1.castShadow = true;
  scene.add(spot1);

  const spot2 = new THREE.SpotLight(0xd6e6ff, 1.1, 28, Math.PI/6, 0.35, 1);
  spot2.position.set(2.8, 4.6, -2.0);
  spot2.castShadow = true;
  scene.add(spot2);

  // ====== Room ======
  const ROOM = { w: 11.5, h: 4.2, d: 16 };
  const wallMat = new THREE.MeshStandardMaterial({ color: 0x1a1f2a, roughness: 0.95 });
  const floorMat = new THREE.MeshStandardMaterial({ color: 0x0f1218, roughness: 1.0 });
  const ceilMat  = new THREE.MeshStandardMaterial({ color: 0x101521, roughness: 1.0 });

  const floor = new THREE.Mesh(new THREE.PlaneGeometry(ROOM.w, ROOM.d), floorMat);
  floor.rotation.x = -Math.PI/2;
  floor.receiveShadow = true;
  scene.add(floor);

  const ceiling = new THREE.Mesh(new THREE.PlaneGeometry(ROOM.w, ROOM.d), ceilMat);
  ceiling.rotation.x = Math.PI/2;
  ceiling.position.y = ROOM.h;
  scene.add(ceiling);

  function makeWall(w, h, pos, rotY){
    const m = new THREE.Mesh(new THREE.PlaneGeometry(w, h), wallMat);
    m.position.copy(pos);
    m.rotation.y = rotY;
    m.receiveShadow = true;
    scene.add(m);
    return m;
  }
  makeWall(ROOM.w, ROOM.h, new THREE.Vector3(0, ROOM.h/2, -ROOM.d/2), 0);
  makeWall(ROOM.w, ROOM.h, new THREE.Vector3(0, ROOM.h/2,  ROOM.d/2), Math.PI);
  makeWall(ROOM.d, ROOM.h, new THREE.Vector3(-ROOM.w/2, ROOM.h/2, 0),  Math.PI/2);
  makeWall(ROOM.d, ROOM.h, new THREE.Vector3( ROOM.w/2, ROOM.h/2, 0), -Math.PI/2);

  // Baseboards
  const baseMat = new THREE.MeshStandardMaterial({ color: 0x0a0c12, roughness: 0.7 });
  const baseH = 0.18, baseT = 0.06;
  function baseboard(len, pos, rotY){
    const b = new THREE.Mesh(new THREE.BoxGeometry(len, baseH, baseT), baseMat);
    b.position.copy(pos);
    b.rotation.y = rotY;
    b.castShadow = true;
    b.receiveShadow = true;
    scene.add(b);
  }
  baseboard(ROOM.w, new THREE.Vector3(0, baseH/2, -ROOM.d/2 + baseT/2), 0);
  baseboard(ROOM.w, new THREE.Vector3(0, baseH/2,  ROOM.d/2 - baseT/2), 0);
  baseboard(ROOM.d, new THREE.Vector3(-ROOM.w/2 + baseT/2, baseH/2, 0), Math.PI/2);
  baseboard(ROOM.d, new THREE.Vector3( ROOM.w/2 - baseT/2, baseH/2, 0), Math.PI/2);

  // ====== Frames / Artworks ======
  const rayTargets = [];
  const loader = new THREE.TextureLoader();

  function addArtwork({file, title}, pos, rotY, size){
    const frameW = size.w, frameH = size.h;
    const depth = 0.08;

    // Frame
    const frame = new THREE.Mesh(
      new THREE.BoxGeometry(frameW + 0.18, frameH + 0.18, depth),
      new THREE.MeshStandardMaterial({ color: 0x0a0c12, roughness: 0.6 })
    );
    frame.position.copy(pos);
    frame.rotation.y = rotY;
    frame.castShadow = true;
    scene.add(frame);

    // Art plane
    const tex = loader.load(`assets/${file}`);
    tex.colorSpace = THREE.SRGBColorSpace;
    tex.anisotropy = renderer.capabilities.getMaxAnisotropy();

    const art = new THREE.Mesh(
      new THREE.PlaneGeometry(frameW, frameH),
      new THREE.MeshStandardMaterial({ map: tex, roughness: 0.95, metalness: 0.0 })
    );

    const forward = new THREE.Vector3(0,0,1).applyAxisAngle(new THREE.Vector3(0,1,0), rotY);
    art.position.copy(pos).add(forward.multiplyScalar(depth/2 + 0.01));
    art.rotation.y = rotY;
    scene.add(art);

    art.userData = { file, title };
    rayTargets.push(art);

    // Tiny plaque (optional minimal)
    const plaque = new THREE.Mesh(
      new THREE.BoxGeometry(Math.min(1.6, frameW), 0.20, 0.04),
      new THREE.MeshStandardMaterial({ color: 0x151a24, roughness: 0.85 })
    );
    plaque.position.copy(pos).add(new THREE.Vector3(0, -(frameH/2 + 0.24), 0)).add(forward.clone().multiplyScalar(depth/2 + 0.02));
    plaque.rotation.y = rotY;
    plaque.castShadow = true;
    scene.add(plaque);
  }

  // Layout: distribute artworks on walls
  // Back wall (z = -d/2)
  addArtwork(ASSETS[0], new THREE.Vector3(-3.2, 2.1, -ROOM.d/2 + 0.01), 0, {w: 3.6, h: 2.0});
  addArtwork(ASSETS[2], new THREE.Vector3( 3.2, 2.1, -ROOM.d/2 + 0.01), 0, {w: 2.8, h: 3.2});

  // Right wall (x = +w/2) rot -PI/2
  addArtwork(ASSETS[3], new THREE.Vector3( ROOM.w/2 - 0.01, 2.1, -4.2), -Math.PI/2, {w: 2.9, h: 3.3});
  addArtwork(ASSETS[4], new THREE.Vector3( ROOM.w/2 - 0.01, 2.0,  0.2), -Math.PI/2, {w: 3.6, h: 2.2});
  addArtwork(ASSETS[5], new THREE.Vector3( ROOM.w/2 - 0.01, 2.1,  4.7), -Math.PI/2, {w: 3.6, h: 2.2});

  // Left wall (x = -w/2) rot +PI/2
  addArtwork(ASSETS[6], new THREE.Vector3(-ROOM.w/2 + 0.01, 2.1, -3.6), Math.PI/2, {w: 3.8, h: 2.2});
  addArtwork(ASSETS[7], new THREE.Vector3(-ROOM.w/2 + 0.01, 2.1,  1.0), Math.PI/2, {w: 3.2, h: 3.4});
  addArtwork(ASSETS[8], new THREE.Vector3(-ROOM.w/2 + 0.01, 2.1,  5.4), Math.PI/2, {w: 3.8, h: 2.2});

  // Front wall (z = +d/2) (a “portrait”)
  addArtwork(ASSETS[1], new THREE.Vector3(0.0, 2.1, ROOM.d/2 - 0.01), Math.PI, {w: 2.8, h: 3.2});

  // ====== Touch controls (iPad only) ======
  // 1 finger: look (yaw/pitch)
  // 2 fingers: move (centroid dy => forward/back; dx => strafe)
  let yaw = 0, pitch = 0;
  const lookSpeed = 0.0024;

  const moveVec = new THREE.Vector2(0,0);
  const velocity = new THREE.Vector3();
  const dir = new THREE.Vector3();

  const touches = new Map(); // id -> {x,y,sx,sy,moved}

  function applyCameraRotation(){
    pitch = Math.max(-Math.PI/2 + 0.05, Math.min(Math.PI/2 - 0.05, pitch));
    camera.rotation.set(pitch, yaw, 0);
  }

  function clampToRoom(pos){
    const margin = 0.40;
    pos.x = Math.max(-ROOM.w/2 + margin, Math.min(ROOM.w/2 - margin, pos.x));
    pos.z = Math.max(-ROOM.d/2 + margin, Math.min(ROOM.d/2 - margin, pos.z));
    pos.y = Math.max(1.2, Math.min(ROOM.h - 0.2, pos.y));
  }

  // Raycaster for taps
  const raycaster = new THREE.Raycaster();
  const ndc = new THREE.Vector2();

  function pickAt(clientX, clientY){
    const rect = renderer.domElement.getBoundingClientRect();
    ndc.x = ((clientX - rect.left) / rect.width) * 2 - 1;
    ndc.y = -(((clientY - rect.top) / rect.height) * 2 - 1);

    raycaster.setFromCamera(ndc, camera);
    const hits = raycaster.intersectObjects(rayTargets, false);
    if (hits.length){
      const { file } = hits[0].object.userData || {};
      if (file){
        openOverlay(`assets/${file}`);
      }
    }
  }

  // Stop page scrolling / bounce
  document.addEventListener("touchmove", (e) => e.preventDefault(), { passive:false });

  let prevCentroid = null;

  function updateMoveFromCentroid(){
    if (touches.size < 2){
      prevCentroid = null;
      moveVec.set(0,0);
      return;
    }
    let cx=0, cy=0, k=0;
    for (const t of touches.values()){ cx += t.x; cy += t.y; k++; }
    cx /= k; cy /= k;

    if (!prevCentroid){
      prevCentroid = { cx, cy };
      moveVec.set(0,0);
      return;
    }
    const dx = cx - prevCentroid.cx;
    const dy = cy - prevCentroid.cy;
    prevCentroid.cx = cx;
    prevCentroid.cy = cy;

    const scale = 0.0042;
    moveVec.x = Math.max(-1, Math.min(1, dx * scale));
    moveVec.y = Math.max(-1, Math.min(1, dy * scale));
  }

  renderer.domElement.addEventListener("pointerdown", (e) => {
    // if fullscreen overlay open: let overlay handle
    if (overlay.style.display === "flex") return;

    renderer.domElement.setPointerCapture(e.pointerId);
    touches.set(e.pointerId, { x:e.clientX, y:e.clientY, sx:e.clientX, sy:e.clientY, moved:false });
  });

  renderer.domElement.addEventListener("pointermove", (e) => {
    if (!touches.has(e.pointerId)) return;
    const t = touches.get(e.pointerId);

    const dx = e.clientX - t.x;
    const dy = e.clientY - t.y;

    t.x = e.clientX; t.y = e.clientY;
    if (Math.hypot(e.clientX - t.sx, e.clientY - t.sy) > 8) t.moved = true;

    if (touches.size === 1){
      // look
      yaw   -= dx * lookSpeed;
      pitch -= dy * lookSpeed;
      applyCameraRotation();
    }
    // movement handled per-frame via centroid
  });

  renderer.domElement.addEventListener("pointerup", (e) => {
    if (!touches.has(e.pointerId)) return;
    const t = touches.get(e.pointerId);
    touches.delete(e.pointerId);

    // Tap => pick (only if we ended a 1-finger gesture and there are no other touches)
    if (!t.moved && touches.size === 0){
      pickAt(e.clientX, e.clientY);
    }
  });

  renderer.domElement.addEventListener("pointercancel", (e) => {
    touches.delete(e.pointerId);
  });

  // ====== Animate ======
  const clock = new THREE.Clock();

  function animate(){
    const dt = Math.min(0.033, clock.getDelta());

    if (overlay.style.display !== "flex"){
      updateMoveFromCentroid();

      // forward: -moveVec.y (dy up => forward)
      const forwardAmt = -moveVec.y;
      const rightAmt   =  moveVec.x;

      const speed = 2.35;

      const forward = new THREE.Vector3(Math.sin(yaw), 0, Math.cos(yaw) * -1);
      const right   = new THREE.Vector3(forward.z * -1, 0, forward.x);

      dir.set(0,0,0);
      dir.addScaledVector(forward, forwardAmt);
      dir.addScaledVector(right, rightAmt);
      if (dir.lengthSq() > 1e-6) dir.normalize();

      const accel = 10.0;
      velocity.x += (dir.x * speed - velocity.x) * Math.min(1, accel * dt);
      velocity.z += (dir.z * speed - velocity.z) * Math.min(1, accel * dt);

      camera.position.x += velocity.x * dt;
      camera.position.z += velocity.z * dt;
      clampToRoom(camera.position);
    }

    renderer.render(scene, camera);
    requestAnimationFrame(animate);
  }
  animate();

  addEventListener("resize", () => {
    camera.aspect = innerWidth/innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(innerWidth, innerHeight);
    renderer.setPixelRatio(Math.max(1, devicePixelRatio || 1));
  });
</script>
</body>
</html>
